await browser.execute(() => {
  const originalFetch = window.fetch;
  window.fetch = async (url, options) => {
    if (url.includes('/logout')) {
      console.log('Mocking logout response');
      return new Response(JSON.stringify({ message: 'logout success' }), {
        status: 200,
        headers: { 'Content-Type': 'application/json' },
      });
    }
    return originalFetch(url, options);
  };
});

await $(dashboardSelectors.logoutButton).click();
await expect($(dashboardSelectors.logoutButton)).toBeDisabled(); // or not clickable

// Also check you're still on the dashboard
await expect(browser).toHaveUrlContaining('/dashboard'); // Or your landing route

Yes, the approach you're using is valid and maintainable — having an array of link selectors and verifying the current URL in a helper function is a good design.

To support multiple possible expected URLs (like one for local and another for CI), you can simply allow expectedUrlContains to accept an array and check if any of them match. Here's how you can modify your utility function:

Step 1: Update the type

export async function verifyInSameTabAndGoBack(expectedUrlContains: string | string[]) {
  await browser.waitUntil(
    async () => {
      const currentUrl = await browser.getUrl();
      if (Array.isArray(expectedUrlContains)) {
        return expectedUrlContains.some((expected) => currentUrl.includes(expected));
      }
      return currentUrl.includes(expectedUrlContains);
    },
    {
      timeout: 10000,
      timeoutMsg: `Expected URL to contain ${JSON.stringify(expectedUrlContains)}, but got ${await browser.getUrl()}`,
    }
  );

  await browser.back(); // Navigate back to original screen
}

Step 2: In your selectors list

Update the object like this:

expectedUrlContains: [
  'soisyst1.standardlife.com/secure/customer-authentication-client/customer/login',
  'localhost:3000/secure/customer-authentication-client/customer/login',
]

This will make your test pass in both local and CI environments reliably without relying on pauses, and still remain readable and scalable.

Let me know if you want to apply this in a loop/test runner setup too!

Yes — that works perfectly and is a robust solution!

Here's how the flow can look:

await logoutButton.click();

// Step 1: Wait for redirection to `/logout`
await browser.waitUntil(
  async () => (await browser.getUrl()).includes('/logout'),
  {
    timeout: 5000,
    timeoutMsg: 'Expected redirection to /logout after clicking logout button',
  }
);

// Step 2: Go back to dashboard
await browser.back(); // navigates back in history

// Step 3: Verify logout button is disabled (confirm logout happened)
await expect(logoutButton).toBeDisabled();

// Step 4: Ensure we're back on the dashboard
await expect(await browser.getUrl()).toContain(urls.localDevDashboard);


---

Why this is solid:

It avoids flaky timing issues.

It confirms both logout redirection and final state (disabled button, dashboard URL).

Works consistently across headless/CI/local modes.


Let me know if you want to wrap this as a helper to reuse!

