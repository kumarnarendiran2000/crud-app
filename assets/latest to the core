JIRA Tech Debt Ticket

Title:

Fix Response Manipulation Issue in AWS Due to Vite Build Optimizations

Description:

We have identified that API responses in the AWS environment are being manipulated post-deployment, specifically the set-cookie header is being truncated. This issue does not occur in local development and appears to be caused by Viteâ€™s build optimizations.

Next Steps:

Investigate how Viteâ€™s build process is modifying the response structure.

Identify and apply the necessary configurations or adjustments to retain the correct API response format.

Validate the fix in AWS to ensure responses match local behavior.


This issue needs to be addressed to prevent inconsistencies between local and production environments.


---

JIRA Comment Update:

All PRs for this ticket have been merged. However, after deployment, we observed that API responses in AWS are being manipulated, leading to the truncation of the set-cookie header. This issue does not occur in local development and seems to be caused by Viteâ€™s build optimizations.

We are currently exploring workarounds to mitigate the issue and will close this ticket once a temporary solution is applied. A tech debt ticket has been created to investigate and implement a permanent fix in the next sprint. Will update once a stable workaround is identified and applied.


Good question! The error handling in slal-axios-config.ts was done using axios.interceptors.response.use, which allows Axios to catch responses before they are passed to the calling function. Since we are using fetch, we need to manually handle errors in our wrapper function.

How to Handle Errors Like slal-axios-config.ts

Interceptors Logic in slal-axios-config.ts

1. If the response status is 401, it removes sensitive cookie data from the error object before logging.


2. It logs a warning and rejects the request with an HTTP 401 Exception.


3. For all other errors, it simply rejects them.




---

Error Handling in Fetch (Equivalent to Axios Interceptors)

We need to replicate the above logic by:

Checking if the response status is 401, and if so, removing sensitive headers before logging.

Throwing a proper HTTPException when SLAL API returns an error.

Handling general errors with logging.



---

Updated Wrapper with Error Handling

import { CONFIG } from '../lambdaContext';
import { constructCookieString, getAuthCookieAndValueForLegacySlalApiCalls } from '../utils/cookie-utils';
import { HTTPException } from 'hono/http-exception';
import logger from '../utils/logger';

export async function getCsrfToken(): Promise<SlalCsrfTokenResponse> {
    const csrfTokenApiEndpoint = '/secure/customer-platform/rest/api/csrfToken';

    // Retrieve auth cookie
    const apiAppConfig = await CONFIG.api();
    const authCookieKeys = apiAppConfig.slalApiAuthCookies;
    const { authCookieName, authCookieValue } = getAuthCookieAndValueForLegacySlalApiCalls(authCookieKeys);

    // Construct headers
    const headers = {
        'Cookie': constructCookieString({ [authCookieName]: authCookieValue }),
        'Accept': 'application/json',
        'Referer': 'your-referer-url', // Replace with actual referer
        'Accept-Encoding': 'gzip, deflate, br'
    };

    try {
        const response = await fetch(`${apiAppConfig.baseSlalUrl}${csrfTokenApiEndpoint}`, {
            method: 'GET',
            headers,
            credentials: 'include' // Ensure cookies are included
        });

        if (!response.ok) {
            // Handle 401 Unauthorized specifically
            if (response.status === 401) {
                logger.warn('Unable to authenticate to SLAL with 401 status');

                // Throw an HTTPException like how Axios did in interceptors
                throw new HTTPException(401, { message: 'Unauthenticated' });
            }

            // Throw a generic error for other response failures
            throw new HTTPException(response.status, { message: 'SLAL API call failed' });
        }

        const responseData = await response.json();
        const setCookieHeader = response.headers.get('set-cookie');

        if (!setCookieHeader || !setCookieHeader.includes('CSRF=')) {
            throw new Error('CSRF cookie missing from SLAL API response');
        }

        return { data: responseData, csrfCookie: setCookieHeader };
    } catch (error) {
        // Remove sensitive cookie information before logging (like interceptors did)
        if (error.headers && error.headers['set-cookie']) {
            delete error.headers['set-cookie'];
        }

        logger.error('SLAL API call failed', error);
        throw error;
    }
}


---

Key Improvements from SLAL Axios Interceptors

âœ… Handles 401 Unauthorized Properly

Logs a warning before throwing an HTTPException(401, { message: 'Unauthenticated' }).


âœ… Removes Sensitive Cookies from Errors

Before logging errors, it removes the set-cookie header (similar to the previous Axios interceptor).


âœ… Handles General Errors Gracefully

Any error response (other than 401) will throw an HTTPException with the correct status code.


âœ… Preserves Logging for Debugging

Errors are logged properly for debugging.



---

Final Summary

This implementation:

1. Bypasses Axios but Preserves All Key Features


2. Ensures Proper Error Handling (like Axios interceptors)


3. Keeps Secure Logging & Cookie Handling


4. Throws Proper Exceptions for 401 and Other Errors



Now, your wrapper is fully equivalent to the Axios setup, but using fetch instead. Let me know if you need any modifications!


When switching from Axios to Fetch, there are key differences in how responses are handled:

Key Differences Between Axios and Fetch

1. Response Data:

In Axios, response.data contains the response body.

In Fetch, you need to explicitly call response.json() (for JSON) or response.text() to parse the response body.



2. Response Headers:

In Axios, response.headers['set-cookie'] directly gives the cookies.

In Fetch, headers are accessed using response.headers.get('set-cookie'), but:

Fetch does not directly support retrieving Set-Cookie headers due to security reasons (CORS policies).






---

Modifying Your Fetch Implementation

Issue 1: Retrieving Response Body Correctly

You need to explicitly call await response.text() if the response body is a string.

Issue 2: Handling Set-Cookie Header

Fetch does not allow access to Set-Cookie headers due to security restrictions in browsers.

In a Node.js environment, this should work:

const setCookieHeader = response.headers.get('set-cookie');

If multiple cookies are sent, they may be combined into a single string instead of an array.



---

Fixing Your Code

Try modifying your code like this:

export async function getCsrfToken(c): Promise<SlalCsrfTokenResponse> {
    const csrfTokenApiEndpoint = '/secure/customer-platform/rest/api/csrfToken';

    const apiAppConfig: ApiConfig = await CONFIG.api();
    const authCookieKeys = apiAppConfig.slalApiAuthCookies;

    const { authCookieName, authCookieValue } = getAuthCookieAndValueForLegacySlalApiCalls(authCookieKeys, getCookie(c));

    const headers = {
        Cookie: constructCookieString({ [authCookieName]: authCookieValue }),
        Accept: 'application/json',
        Referer: c.req.url,
        'Accept-Encoding': 'gzip, deflate, br',
    };

    const subSegment = Xray.addNewSubSegment(`Call to ${csrfTokenApiEndpoint}`);

    try {
        const response = await fetch(`${apiAppConfig.baseSlalUrl}${csrfTokenApiEndpoint}`, {
            method: 'GET',
            headers,
        });

        // Get response body
        const responseData = await response.text(); // Use .text() if data is plain text

        // Extract Set-Cookie headers
        const setCookieHeader = response.headers.get('set-cookie'); // Fetch may not expose this

        // Handle CSRF Cookie Extraction
        const csrfCookie = setCookieHeader?.split(';').find(cookie => cookie.startsWith('CSRF='));

        if (!csrfCookie) {
            throw new Error('CSRF cookie missing from SLAL csrfToken API response');
        }

        return SlalCsrfTokenSchema.parse({
            data: responseData,
            csrfCookie,
        });

    } catch (error) {
        Xray.addError(subSegment, error);
        throw error;
    } finally {
        Xray.closeSubSegment(subSegment);
    }
}

Key Fixes:

1. Used response.text() to correctly retrieve the response body.


2. Used response.headers.get('set-cookie') to extract the Set-Cookie header.


3. Used .split(';') to extract the CSRF cookie.


4. Explicitly handling the case where the CSRF cookie is missing.



Potential Issues

If fetch() is running in a browser, it cannot access Set-Cookie headers due to CORS.

If fetch() is running in Node.js (Lambda), this should work correctly.


Next Steps:

If set-cookie is still missing in fetch(), you may need to log response.headers and check what headers are available.

If the response is not structured as expected, log await response.text() instead of json().


If startsWith doesn't work because the CSRF cookie is clumped with other cookies, you can split the string properly and extract the CSRF cookie.

Updated Approach to Extract CSRF Cookie

const setCookieHeader = response.headers.get('set-cookie');

if (!setCookieHeader) {
  throw new Error('Set-Cookie header is missing from the response');
}

// Ensure it's treated as an array
const cookiesArray = Array.isArray(setCookieHeader) ? setCookieHeader : [setCookieHeader];

// Flatten if needed (sometimes set-cookie is a single string with multiple cookies)
const allCookies = cookiesArray.flatMap(cookie => cookie.split(/, (?=[^;]+?=)/)); 

// Find the CSRF cookie
const csrfCookie = allCookies.find(cookie => cookie.includes('CSRF='));

if (!csrfCookie) {
  throw new Error('CSRF cookie missing from SLAL csrfToken API response');
}

console.log("Extracted CSRF Cookie:", csrfCookie);


---

Why This Works

âœ… Handles multiple cookies in a single string by properly splitting them using regex.
âœ… Extracts the CSRF cookie even if itâ€™s clumped together with others.
âœ… Works for both array-based and string-based set-cookie headers.

This approach ensures that even if the cookies are in one long string, the CSRF cookie is correctly extracted.


---

Does this work for your case?


Yes, you can replace throw error; with return Promise.reject(error); in both error-handling cases to align more closely with the way Axios interceptors handle errors. This makes it explicit that the function will return a rejected Promise instead of throwing an exception synchronously.

Updated Code with Promise.reject(error)

export async function getCsrfToken(c): Promise<SlalCsrfTokenResponse> {
  const csrfTokenApiEndpoint = `/secure/customer-platform/rest/api/csrfToken`;

  const apiAppConfig: ApiConfig = await CONFIG.api();
  const authCookieKeys = apiAppConfig.slalApiAuthCookies;

  const { authCookieName, authCookieValue } = 
    getAuthCookieAndValueForLegacySlalApiCalls(authCookieKeys, getCookie(c));

  const headers = {
    Cookie: constructCookieString({
      [authCookieName]: authCookieValue,
    }),
    Accept: 'application/json',
    Referer: c.req.url,
    'Accept-Encoding': 'gzip, deflate, br',
  };

  const subSegment = Xray.addNewSubSegment(`Call to ${csrfTokenApiEndpoint}`);

  try {
    const response = await fetch(`${apiAppConfig.baseSlalUrl}${csrfTokenApiEndpoint}`, {
      method: 'GET',
      headers,
    });

    if (!response.ok) {
      let errorData;
      try {
        errorData = await response.json(); // Try to extract JSON error response
      } catch {
        errorData = response.statusText; // Fallback if response is not JSON
      }

      // Handle 401 Unauthorized error
      if (response.status === 401) {
        // Remove sensitive data (Cookie) from error headers before logging in production
        if (apiAppConfig.isProduction && headers.Cookie) {
          delete headers.Cookie;
        }

        logger.warn('Unable to authenticate to SLAL with 401 status', errorData);
        return Promise.reject(new HTTPException(401, { message: 'Unauthenticated' }));
      }

      return Promise.reject(new Error(`SLAL API error: ${response.status} - ${response.statusText}`));
    }

    const responseData = await response.json();
    const setCookieHeader = response.headers.get('set-cookie');

    // Extract CSRF cookie
    const csrfCookie = setCookieHeader?.split(';').find((cookie) => cookie.includes('CSRF='));
    if (!csrfCookie) {
      return Promise.reject(new Error('CSRF cookie missing from SLAL csrfToken API response'));
    }

    return SlalCsrfTokenSchema.parse({
      data: responseData,
      csrfCookie,
    });

  } catch (error) {
    // Ensure error logging does not include sensitive Cookie information
    if (apiAppConfig.isProduction && error.config?.headers?.Cookie) {
      delete error.config.headers.Cookie;
    }

    Xray.addError(subSegment, error);
    return Promise.reject(error);  // Returning a rejected promise instead of throwing
  } finally {
    Xray.closeSubSegment(subSegment);
  }
}

Why Use Promise.reject(error)?

1. Consistency with Axios Behavior: Axios's interceptors return Promise.reject(error) rather than throwing directly, which allows better chaining in async functions.


2. Prevents Uncaught Errors: When using throw, unhandled errors may bubble up unpredictably. Returning a rejected Promise ensures they can be handled properly with .catch() or try/catch in the calling function.


3. Better Error Handling in Promise Chains: Using Promise.reject(error) makes error propagation smoother for functions that rely on .then() and .catch().



Final Behavior

If SLAL returns a 401, logs the warning and returns Promise.reject(new HTTPException(401, { message: 'Unauthenticated' }))

If SLAL returns another HTTP error, rejects the Promise with the response status.

If the CSRF cookie is missing, rejects with a specific error.

Errors during the request process are caught and rejected properly.


This ensures that your function behaves the same way as the Axios interceptor while being adapted for fetch. ðŸš€


