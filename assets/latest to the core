JIRA Tech Debt Ticket

Title:

Fix Response Manipulation Issue in AWS Due to Vite Build Optimizations

Description:

We have identified that API responses in the AWS environment are being manipulated post-deployment, specifically the set-cookie header is being truncated. This issue does not occur in local development and appears to be caused by Vite’s build optimizations.

Next Steps:

Investigate how Vite’s build process is modifying the response structure.

Identify and apply the necessary configurations or adjustments to retain the correct API response format.

Validate the fix in AWS to ensure responses match local behavior.


This issue needs to be addressed to prevent inconsistencies between local and production environments.


---

JIRA Comment Update:

All PRs for this ticket have been merged. However, after deployment, we observed that API responses in AWS are being manipulated, leading to the truncation of the set-cookie header. This issue does not occur in local development and seems to be caused by Vite’s build optimizations.

We are currently exploring workarounds to mitigate the issue and will close this ticket once a temporary solution is applied. A tech debt ticket has been created to investigate and implement a permanent fix in the next sprint. Will update once a stable workaround is identified and applied.


Good question! The error handling in slal-axios-config.ts was done using axios.interceptors.response.use, which allows Axios to catch responses before they are passed to the calling function. Since we are using fetch, we need to manually handle errors in our wrapper function.

How to Handle Errors Like slal-axios-config.ts

Interceptors Logic in slal-axios-config.ts

1. If the response status is 401, it removes sensitive cookie data from the error object before logging.


2. It logs a warning and rejects the request with an HTTP 401 Exception.


3. For all other errors, it simply rejects them.




---

Error Handling in Fetch (Equivalent to Axios Interceptors)

We need to replicate the above logic by:

Checking if the response status is 401, and if so, removing sensitive headers before logging.

Throwing a proper HTTPException when SLAL API returns an error.

Handling general errors with logging.



---

Updated Wrapper with Error Handling

import { CONFIG } from '../lambdaContext';
import { constructCookieString, getAuthCookieAndValueForLegacySlalApiCalls } from '../utils/cookie-utils';
import { HTTPException } from 'hono/http-exception';
import logger from '../utils/logger';

export async function getCsrfToken(): Promise<SlalCsrfTokenResponse> {
    const csrfTokenApiEndpoint = '/secure/customer-platform/rest/api/csrfToken';

    // Retrieve auth cookie
    const apiAppConfig = await CONFIG.api();
    const authCookieKeys = apiAppConfig.slalApiAuthCookies;
    const { authCookieName, authCookieValue } = getAuthCookieAndValueForLegacySlalApiCalls(authCookieKeys);

    // Construct headers
    const headers = {
        'Cookie': constructCookieString({ [authCookieName]: authCookieValue }),
        'Accept': 'application/json',
        'Referer': 'your-referer-url', // Replace with actual referer
        'Accept-Encoding': 'gzip, deflate, br'
    };

    try {
        const response = await fetch(`${apiAppConfig.baseSlalUrl}${csrfTokenApiEndpoint}`, {
            method: 'GET',
            headers,
            credentials: 'include' // Ensure cookies are included
        });

        if (!response.ok) {
            // Handle 401 Unauthorized specifically
            if (response.status === 401) {
                logger.warn('Unable to authenticate to SLAL with 401 status');

                // Throw an HTTPException like how Axios did in interceptors
                throw new HTTPException(401, { message: 'Unauthenticated' });
            }

            // Throw a generic error for other response failures
            throw new HTTPException(response.status, { message: 'SLAL API call failed' });
        }

        const responseData = await response.json();
        const setCookieHeader = response.headers.get('set-cookie');

        if (!setCookieHeader || !setCookieHeader.includes('CSRF=')) {
            throw new Error('CSRF cookie missing from SLAL API response');
        }

        return { data: responseData, csrfCookie: setCookieHeader };
    } catch (error) {
        // Remove sensitive cookie information before logging (like interceptors did)
        if (error.headers && error.headers['set-cookie']) {
            delete error.headers['set-cookie'];
        }

        logger.error('SLAL API call failed', error);
        throw error;
    }
}


---

Key Improvements from SLAL Axios Interceptors

✅ Handles 401 Unauthorized Properly

Logs a warning before throwing an HTTPException(401, { message: 'Unauthenticated' }).


✅ Removes Sensitive Cookies from Errors

Before logging errors, it removes the set-cookie header (similar to the previous Axios interceptor).


✅ Handles General Errors Gracefully

Any error response (other than 401) will throw an HTTPException with the correct status code.


✅ Preserves Logging for Debugging

Errors are logged properly for debugging.



---

Final Summary

This implementation:

1. Bypasses Axios but Preserves All Key Features


2. Ensures Proper Error Handling (like Axios interceptors)


3. Keeps Secure Logging & Cookie Handling


4. Throws Proper Exceptions for 401 and Other Errors



Now, your wrapper is fully equivalent to the Axios setup, but using fetch instead. Let me know if you need any modifications!

